val flatten :: Monad m => m (m a) -> m a
let flatten xs = bind xs id  

val sequenceA :: (Applicative f, Traversable t) => t (f a) -> f (t a)
let sequenceA = traverse id

val liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
let liftA2 f m n = (pure f) <*> m <*> n

val jsonData :: Async String
let jsonData = httpGet "https://query1.finance.yahoo.com/v8/finance/chart/AAPL" 

val getData :: String -> Maybe Json
let getData = parseJson >=> 
              getJsonValue "chart" >=> 
              getJsonList "result" >=> 
              (Just . head) 
  
val getClose :: Json -> Maybe (List Double)      
let getClose = getJsonValue "indicators" >=> 
               getJsonList "quote" >=> 
               (Just . head) >=>
               getJsonList "close" >=>
               traverse jsonToDouble

val getTimestamps :: Json -> Maybe (List String)
let getTimestamps v = 
  bind (getJsonList "timestamp" v)(\r -> 
  fmap (fmap timeStampToDate) (traverse jsonToInt r))

val spotData :: String -> Maybe ((List String, List Double))
let spotData v = bind (getData v)(\z -> 
                 liftA2 (\x y -> (x, y))
                        (getTimestamps z)
                        (getClose z))
 
val main :: Async (Maybe Unit) 
let main =  flatten (fmap sequenceA (
            bind jsonData (\x -> 
            pure (bind (spotData x) (\(xs, ys) ->
            pure (renderTimeSeries (xs, ys)))))  
            ))
  