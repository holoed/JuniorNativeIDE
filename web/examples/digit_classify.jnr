
val dataSet :: Async (List Int)
let dataSet = (bufferToIntList . decompress) <$> httpGet "http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz" 

val labels :: Async (List Int)
let labels = (bufferToIntList . decompress) <$> httpGet "http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz"

val indexToVec :: Int -> List Double
let indexToVec n = range (\x -> if x == n then 1.0 else 0.0) 0 9

val toImg :: Int -> List a -> List (List a)
let toImg n s = 
  let sz = 28 in
  let s' = (take (sz^2) . drop (16 + n*sz^2)) s in
  split sz s'         
          
val mkTensor :: List (List (List Int)) -> Tensor2D
let mkTensor xsss = mkTensor2D ((\xss -> xss >>= (\xs -> xs >>= (\x -> [toDouble x]))) <$> xsss) (28*28)

val brain :: FeedForwardModel
let brain = feedForwardModel [(28*28), 512, 256, 10]    

val inputTensor :: Async Tensor2D
let inputTensor = mkTensor <$> ((\ds -> range (flip toImg ds) 0 4) <$> dataSet) 
 
val testTensor :: Async Tensor2D
let testTensor = mkTensor <$> ((\ds -> range (flip toImg ds) 0 4) <$> dataSet)

val outputTensor :: Async Tensor2D
let outputTensor = flip mkTensor2D 10 <$> (((\xs -> indexToVec <$> xs) . take 5 . drop 8) <$> labels) 

val trainedBrain :: Async TrainedFeedForwardModel
let trainedBrain = inputTensor >>= (\i -> 
                   outputTensor >>= (\o -> trainModel brain i o 1000 True)) 

val main :: Async (List (List Int))
let main = testTensor >>= (\tt -> (flip predict tt) <$> trainedBrain >>= tensor2DToArray >>= pure . ((<$>)((<$>) round)))