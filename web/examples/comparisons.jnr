val jsonData :: String -> Async String
let jsonData symbol = httpGet ("https://query1.finance.yahoo.com/v8/finance/chart/" <> symbol)

val getData :: String -> Maybe Json
let getData = parseJson >=> getJsonValue "chart" >=> getJsonList "result" >=> listToMaybe 
              
let getSymbol = getJsonValue "meta" >=> getJsonValue "symbol" >=> jsonToString  

let getPreviousClose = getJsonValue "meta" >=> getJsonValue "previousClose" >=> jsonToDouble  
  
val getClose :: Json -> Maybe (List Double)      
let getClose = getJsonValue "indicators" >=> 
               getJsonList "quote" >=>  
               listToMaybe >=> 
               getJsonList "close" >=>
               traverse jsonToDouble                  
   
val getTimestamps :: Json -> Maybe (List String)     
let getTimestamps v = 
  bind (getJsonList "timestamp" v)(\r ->     
  fmap (fmap timeStampToDate) (traverse jsonToInt r))   
 
val normalize :: Double -> List Double -> List Double
let normalize c xs = fmap (\x -> if (x == 0) then x else 100 * (x - c) / c) xs 

val spotData :: String -> Maybe ((String, List String, List Double)) 
let spotData v = bind (getData v)(\z ->    
                 pure (\x y c z -> (x, y, normalize c z))
                      <*> (getSymbol z)  
                      <*> (getTimestamps z) 
                      <*> (getPreviousClose z)
                      <*> (getClose z))

val ticker :: String -> Async (List ((String, List String, List Double)))
let ticker symbol = bind (jsonData symbol) (\x -> pure ((maybeToList . spotData) x))
 
let tickers = ["^IXIC", "H", "RKLB", "AMAT", 
               "AAPL", "TSLA", "AMD", "MAR",  
               "NVDA", "GOOGL", "AVGO", "LMT", "QCOM", 
               "FB", "U", "ETSY", "TWTR"]
 
let main = bind (fmap flatten (sequenceA (fmap ticker tickers))) renderTimeSeries 
  
      
               